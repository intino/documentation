---
title: "Magritte"
date: 2024-07-18T15:26:15Z
draft: false
weight: 1
---
## What is Magritte?

The Magritte framework is a versatile tool designed to facilitate the execution of Tara models. Its functionality lies in its ability to combine core code with generated code, adapting to various model definitions. Magritte enables efficient execution of Tara models, regardless of the specific specifications of these models. Among its notable features is the ability to identify and manage fundamental concepts essential for the execution of Tara models. Additionally, it provides support for handling dynamic polymorphism, allowing for effective management of dynamic addition and removal of facets in nuclear concepts. In summary, Magritte offers a practical and flexible solution for executing Tara models, standing out for its ability to adapt to different contexts and user needs.

## Architecture

Magritte consists of two essential components: the codebase and the code generator. The codebase forms the bedrock of the framework, offering crucial support for executing Tara models. Within this foundational library, core concepts are meticulously crafted to meet the specific needs of model execution. These core concepts encapsulate the fundamental structures, functions, and interactions essential for the seamless functioning of Tara models. With a robust and purpose-built codebase, Magritte ensures a reliable and efficient execution process.

The code generator complements the codebase by dynamically building classes based on interpreted Tara models. It acts as a bridge between abstract definitions within a Tara model and practical implementation details in programming languages like Java. Proficient at parsing Tara models intricacies, the code generator autonomously generates classes aligning with the model's domain concepts. This automation accelerates implementation and equips programmers with a ready-to-use set of classes. By seamlessly translating Tara models into executable code, Magritte's code generator enhances the accessibility and usability of Tara models, offering a more intuitive and developer-friendly experience.

<div style="text-align: center;margin-top: 40px;">
  <img src="../../../images/magritte_architecture.png" alt="Architecture" style="width: 50%;">
</div>

## Codebase

Let's break down the architecture of Magritte's codebase in a user-friendly manner. At the heart of Magritte's design is a graph-based structure, visualized through a Unified Modeling Language (UML) diagram. This structure revolves around classes and nodes, which together form the backbone of your model.

* **Graph Structure:** The class graph is central to Magritte's architecture. It's like a map that guides the behavior of your model. Imagine you're modeling a city. Magritte's graph wrappers help you navigate through essential elements like buildings, cars, and roads. These wrappers are dynamically generated by Magritte's code generator, ensuring they fit seamlessly into your specific model.

* **Concepts and Nodes:** In Magritte, concepts are like the guiding principles of your model, similar to how Java uses reflection. They define relationships, attributes, and parameters. Nodes, on the other hand, are instances of concepts. They represent specific objects within your model, like a particular building or car. Nodes can dynamically adapt, with layers representing different aspects that can be added or removed during runtime. This flexibility allows your model to evolve without starting from scratch, a feature known as dynamic polymorphism. For instance, in a school setting, a teacher might temporarily take on the role of a parent, and Magritte allows you to adjust the node accordingly.

* **Code Generation:** Magritte's code generator is a key player. It automatically creates classes tailored to your model's specifications. For example, if your model includes different types of cars, the code generator generates classes for each type, like a regular car and an electric car. These generated classes enable smooth interaction with nodes in your model, ensuring everything runs seamlessly.

* **Graph Persistence:** Magritte's codebase offers a convenient way to persist your graph data into smaller, more manageable packages called stashes. These stashes logically organize root nodes based on their stash identifier. What's neat is that you can implement this persistence system using various methods like in-memory data storage, hard disk, or cloud storage, thanks to its adherence to a Liskov contract.

* **Cloning Graphs and Nodes:** Sometimes, you might need to work with copies of your graphs or nodes for specific purposes. Magritte's codebase allows you to clone both graphs and nodes effortlessly. This feature comes in handy when loading the entire structure into memory isn't feasible, or when you need to diverge graphs or nodes for different applications.

* **Executing Inserted Functions:** Magritte's codebase also empowers you to execute functions that you've inserted into your Tara models. These Tara models can integrate native code, usually in Java, which the code generator translates into Java classes. These classes can then be executed by the codebase, performing tasks like initializing variables or acting as callable methods that you can query at different stages of execution. This capability adds a layer of flexibility to your model execution, allowing you to incorporate custom functionalities seamlessly.

<div style="text-align: center;margin-top: 40px">
  <img src="../../../images/magrite_codebase.png" alt="Codebase" style="width: 80%;">
</div>

## Code Generator

The Magritte compiler, part of the Tara language family, stands as a pioneering tool in the realm of software development. Acting as an extension to the standard Tara compiler, it harnesses Tara's flexibility and robustness to introduce advanced functionalities.

* **Custom Operations with Tara:** One of the key strengths of the Tara compiler is its ability to incorporate specific operations during the code generation phase. This feature is pivotal for Magritte's code generator, enabling the transformation of high-level concepts from DSL models into executable code seamlessly.

* **From DSL Models to Java Code:** The process unfolds with users defining models in Tara's DSL, containing mograms (model diagrams) representing their abstractions. Leveraging a predefined set of rules, Magritte's code generator translates these high-level abstractions into specific Java code. Each concept gets its wrapper class, bearing its unique attributes and constraints. The generated code ensures that semantic constraints declared in the language are maintained at runtime. It facilitates the creation and deletion of mogram instances in the graph, adhering to their semantics. Additionally, the generated code registers mogram types from the abstraction level in Magritte's engine, establishing relationships between concepts (M2) and meta-concepts (M3).

* **Efficient Graph Representation:** Once concepts are registered in Magritte's engine, the code generator aids in creating an in-memory graph. This graph goes beyond a mere collection of nodes and relationships; it encapsulates the semantics defined by users in the DSL. By storing semantics in a graph structure, Magritte enables more efficient manipulation and analysis of defined concepts, streamlining complex operations.

## Codebase and Code Generator Integration

The seamless integration between the codebase and the generated code is essential for executing Tara models effectively. The code generator serves as the linchpin in this process, crafting tailored code based on the model definitions provided. Moreover, it generates Java definitions, enabling the codebase to recognize classes extending from it.

This integration is made possible by Tara's multilevel capability. Each level features a set of classes representing reality at different levels of abstraction. This framework construction at specific abstraction levels fosters reusability across subsequent levels.

Let's consider a simulation scenario as an example. At the platform level, we have a simulation engine capable of perceiving generic entities and behaviors. These entities and behaviors are context-neutral at this stage. However, as we delve deeper into specific simulation contexts, customization becomes feasible. For instance, in simulating a power grid, entities can be tailored to represent power grid elements. Here, domain experts interact with power grid elements while leveraging the abstracted simulation engine. The engine drives the simulation by focusing solely on entity and behavior existence, irrespective of context specifics.

This multilevel abstraction promotes framework reuse across diverse tasks at a high level of abstraction, from executing simulations to generating reports and beyond. Through seamless integration of the codebase and generated code, we create a flexible, potent tool adaptable to various needs while operating at the most abstract level.
